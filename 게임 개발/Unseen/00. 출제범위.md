# 출제 범위

## 1. 객체지향 프로그래밍

- 객체 지향 프로그래밍 특징

## 2. C++ 프로그래밍

- C++ 언어 특징

## 3. 시스템 프로그래밍

- 메모리 ( 힙과 스택 )

## 4. 자료구조

- 주요 컨테이너 ( map, Unordered_map, list, vector, array ) 동작원리

## 5. 게임 알고리즘

- A* 길찾기, FSM, 비헤이비어트리, Quadtree 공간 분할

## 6. 게임 수학

- 게임에서의 벡터, 행렬, 내적, 외적의 활용, 회전의 표현

## 7. 언리얼 C++ 프로그래밍 

- 언리얼 엔진이 사용하는 C++ 프로그래밍 프레임웍

## 8. 언리얼 게임 프레임웍

- 언리얼 엔진이 게임 제작을 위해 제공하는 프레임웍에 대한 기초지식

## 출제 예시

- 객관식 예시

  Q) 게임 제작에서 이동, 크기, 회전으로 구성된 트랜스폼을 사용해 물체를 변환할 때 변환 순서를 올바로 기술한 것을 고르시오.

  1) 이동 --> 크기 --> 회전
  2) 크기 --> 회전 --> 이동
  3) 회전 --> 크기 --> 이동
  4) 크기 --> 이동 --> 회전

  --> `2`번 이다. 이 순서는 트랜스폼의 행렬 연산 순서와 관련이 있다. 행렬 연산은 결합 법칙은 성립하지만, 교환 법칙은 성립하지 않는다. 따라서 연산의 순서가 결과에 영향을 미친다. 일반적으로 크기 변경을 먼저 하고, 그 다음에 회전을 하며, 마지막으로 이동을 한다. 이렇게 하면 의도한 대로 물체를 변환할 수 있다. 다른 순서로 변환을 하면 의도하지 않은 결과를 얻을 수 있다. 예를 들어, 이동을 먼저 하고 회전을 하면 물체는 원점을 중심으로 회전하지 않고, 이동한 위치를 중심으로 회전하게 된다. 변환의 순서는 중요하다.

- 주관식 예시

  Q) 객체 지향 언어를 사용할 때 유연하고, 확장이 쉽고, 유지보수를 편리하기 하기 위해 제공되는 보편적인 5가지 원리(Principle)가 있다. 이 다섯 가지 원리의 앞글자를 모두 붙여 만든 단어를 모두 대문자로 쓰시오.

  --> 정답은 `SOLID` 이다.

  1. Single Responsibility Principle (SRP, 단일 책임 원칙)
     - 클래스가 단 하나의 책임을 가져야 한다는 것을 의미, 즉 클래스는 하나의 기능만을 가지며, 그 기능이 변경될 때만 해당 클래스를 수정해야한다.
  2. Open / Closed Principle (OCP, 개방-폐쇄 원칙)
     - 소프트웨어 개체 (클래스, 모듈, 함수 등)는 확장에 대해서는 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다는 것을 의미. 즉, 기존의 코드를 변경하지 않고도 기능을 추가하거나 변경할 수 있어야 한다.
  3. Liskov Substitution Principle (LSP, 리스코프 치환 원칙)
     - 서브타입은 그것의 기본 타입으로 치환될 수 있어야 한다는 것을 의미. 즉, 자식 클래스는 부모 클래스의 역할을 완벽하게 대체할 수 있어야 한다.
  4. Interface Segregation Principle (ISP, 인터페이스 분리 원칙)
     - 클라이언트는 자신이 사용하지 않는 인터페이스에 의존하면 안된다는 것을 의미. 즉, 한 클래스는 자신이 필요로 하는 메서드만을 가진 인터페이스에만 의존해야 한다.
  5. Dependency inversion principle (DIP, 의존 역전 원칙)
     - 상위 모듈은 하위 모듈에 의존해서는 안되며, 둘 다 추상화에 의존해야 한다는 것을 의미. 즉, 구체적인 클래스에 의존하는 대신 인터페이스나 추상 클래스에 의존해야 한다.

  유연성, 확장성, 유지보수성을 높이는 데 도움이 된다.

  Q) 다음 언리얼 오브젝트를 상속받은 클래스에 Name 멤버 변수와 BuildProjcet 멤버 함수를 언리얼 엔진이 파악해 관리하도록 매크로를 부여하고자 한다. 멤버 변수와 멤버 함수에 부여할 매크로를 추가하시오.

  ```C++
  UCLASS()
  class UNSEEN_API UStudent : publioc UObject
  {
      GENERATED_BODY()
          
  public:
   	UStudent();
      
      // 매크로를 추가하시오.
      UFUNCTION(BlueprintCallable, Category = "Your Category")
      virtual void BulidProjcet();
  
  protected:
      
      // 매크로를 추가하시오.
      UPROPERTY(VisibleAnywhere, BluyeprintReadOnly, Category = "Your Category")
      FString Name;
  };
  ```

  --> 언리얼 엔진에서 클래스의 멤버 변수와 함수를 관리하려면 UPROPERTY와 UFNCTION 매크로를 사용해야하고, 이 매크로들은 언리얼 엔진의 가비지 컬렉션, 네트워킹, 블루프린트 등과 같은 시스템과 상호 작용하는 데 필요하다. 이 코드 에서 `UPROPERTY` 매크로는 `Name` 멤버 변수를 언리얼 엔진이 인식하도록 하며, `UFUNCTION` 매크로는 `BuildProject` 멤버 함수를 언리얼 엔진이 인식하도록 한다. 이렇게 하면 언리얼 엔진의 다양한 시스템과 상호 작용할 수 있다. 매크로에 전달된 인자들은 해당 멤버 변수나 함수의 동작을 언리얼 엔진 내에서 어떻게 처리할지를 정의한다. 이 예제에서는 변수와 함수가 블루프린트에서 보이고, 블루프린트에서 호출 가능하도록 설정되어 있다. 다른 인자들을 사용하여 다양한 동작을 설정할 수도 있다.